冒泡排序

1. 先比较0和1位置上的数，若0位置比1位置小则交换；再依次比较1和2位置...，比较N-2和N-1位置。最后，最大的数放在末尾。

2. 比较0和1位置，再依次比较1和2位置...，比较N-3和N-2位置。

   时间复杂度：$O(N^2)$

   

选择排序

1. 0到N-1上最小的数放到0位置；

2. 1到N-1上最小的数放到1位置。

   

插入排序

1. 先保持0位置的数不变；

2. 1位置与0位置比较，若小则交换；排好0~1范围的数。

3. 2位置与1位置比较，若小则交换，再与0位置比较；若2位置一上来就比1位置大，则直接排好0~2位置的数。

   若数组已经排好序，时间复杂度为$O(N)$。



**对数器**：验证算法是否正确的一种方式。

基本概念与使用：

1. 有一个想测试的算法a；

2. 实现一个绝对正确但复杂度高的算法b；

3. 实现一个随机样本产生器；

4. 实现比对算法a和b的方法；

5. 多次（100000+）比对算法a和b来验证a是否正确；

6. 如果有样本出错，则打印出来分析；

7. 当对比测试都正确时，可基本判断算法a正确。

   

https://segmentfault.com/a/1190000016911927?utm_source=tag-newest

______

### 递归行为时间复杂度的估算

$$
T(N)=aT(N/b)+O(N^d)
$$



$T(N)$样本量为$N$的情况下的时间复杂度。$N/b$指子问题的样本量，$a$指子过程一共发生多少次。$O(N^d)$除去调用子过程，剩下的时间复杂度。

若$log_ba>d$，时间复杂度为$O(N^{log_ba})$。

若$log_ba=d$，时间复杂度为$O(N^dlogN)$。

若$log_ba<d$，时间复杂度为$O(N^d)$。

适用于划分的子问题的规模是一样的。

____

归并排序

 1. 把待排序区间$[s, t]$以中点二分，接着把左边子区间排序，再把右边子区间排序，最好把左右区间通过归并操作合并成有序的区间。

 2. 归并操作的工作原理：

    a. 申请空间，用来存放合并后的序列；

    b. 设定两个指针，最初位置分别为两个已经排序序列的起始位置。

    c. 比较两个指针所指的元素，选择相对小的元素放入合并空间，并移动指针到下一个位置。

时间复杂度为$O(NlogN)$。

$mid=L+\frac{R-L}{2}$：防溢出。等价于$mid=L+(R-L)>>1$。

